Web Developer Tools
===================
David Mendoza <jdmendoza@swau.edu>
v1.0, 2016-10-19
:toc: left
:imagesdir: assets/images
:source-highlighter: pygments
:icons: font

== Objectives
This workshop's objectives are to help you acquire tools that will allow you to be better prepared for when the time comes to look for a web developer or a web administrator position (so it's not 'how to code in java', or 'how to do C++ right').

== Introduction
To do web development we need to understand what it involves. It's simple really but let's just state it to have a common ground. We'll have our user client which is going to open up a browser and type in the URL box the address of our service. A server is going to be listening and will produce the HTML the client's browser needs to show what we want the client to see. To produce this content the server will probably need to access a repository, which most of the times is a database. The client then will start interacting with the application in the browser, the browser will send the information to the server to be processed and the server will store it in the database if it needs to.

== Developer Machine Setup
=== Linux
==== Why are we using Linux?
Most of the deployments are done on UNIX based systems, so I found it more of a 'necessity' than 'a good to have' in my line of work. A lot of workspaces have limited IT budgets, and Linux gets you a lot of stuff for free. So that's why I want them to pick up this tool as we go.

==== Which distribution should I use?
There are a lot of Linux distributions out there, but most are based on only a few, one of the most solid ones is Debian, Fedora would be another one, and anyone will do as long as it allows to install packages and you make sure that the community behind it is big and knowledgeable. I prefer the distributions based on Debian, so the instructions will be for Debian based distributions.

==== Basic Linux Setup
The Linux Operating System is an evolving environment. What this means is that the system is always being worked on and updated, some distributions provide expected timeframes for their releases, but the reality is that there are so many developers working on the different parts that conform the Linux Operating System that in between these timeframes there's a lot of little releases going on for different parts of the Operating System.

To make it work, each base distribution has created a repository with the packages that the system needs and the ones that can be added to it.

==== Terminal
Knowing your way around on a UNIX/Linux system is essential. And though we have a GUI environment, we'll have to get used to working on a terminal to gain the experience we will need when we actually do the deployment on a server (which most of the time doesn't have a GUI).

The basic commands you'll need to use the terminal are:

ls:: Shows the files in the folder.
cp:: Copies files from source to destination
mv:: Moves files from source to destination.
ln:: Creates hard or soft links.
tar:: Combines files into a single file, it also extracts the files from that single file.
zip & unzip:: Do the same thing as *_tar_* but with a different file format. Some distributions don't provide this tool by default so you might need to install it.

For a Debian-based distribution you need to run in a terminal:

[source,sh]
----
sudo apt-get update
----

You'll notice the first word of this instruction is *_sudo_*. Most Linux systems have a super user called *_root_*. This user can do everything on the system, even destroy it. To prevent users from doing _stuff_ to the system without warning, the *_sudo_* instruction was created. It allows the user granted this privilege to run instructions as root. The next instruction is *_apt-get_* which is how Debian based systems interact with the remote repositories list and the local one. And finally, *_update_* is to sync the remote package repositories list with the local one.

Once the system has finished updating the lists, you need to run:

[source,sh]
----
sudo apt-get upgrade
----

We need to keep doing these two instructions on a regular basis on our Linux boxes to keep them up to date and secure.

==== Vi Editor

Vi is a powerful editor and it comes with almost every Linux distribution. I'll show you the basics of this tool. To move around use *_j_* or *_k_*. To go to the end of the file is *_G_* and to go to the beginning of the file use *_gg_*. You'll notice that you can't modify the file even though you're in the right spot, that's because you're in command mode, to insert changes where you're at use *_i_*, to append use *_a_*, to add a new line use *_o_* and to go back to command mode press the *_esc_* key. Special commands start with a colon (*_:_*). For instance *_:q_* is quit, *_:w_* is save, and you can use them together to save and quit *_:wq_*. If you made changes and you try to quit without saving, it won't let you quit until you save or force quit with *_:q!_*.

=== Java

We'll proceed to set up Java on our machine by adding the java package repository URL to our *_sources.list_* file.

[source,sh]
----
sudo vi /etc/apt/sources.list
----

Go to the end of the file (*_G_*) and add a new line (*_o_*) and paste the following line:

[source,sh]
----
deb http://ppa.launchpad.net/webupd8team/java/ubuntu trusty main
----

We save and exit the file by getting out of *_INSERT_* mode by pressing the *_esc_* key, and then the instruction *_:wq_* (or the shorthand *_:x_*).

[source,sh]
----
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys EEA14886 # <1>
sudo apt-get update # <2>
sudo apt-get install oracle-java8-installer # <3>
sudo ln -s /usr/lib/jvm/java-8-oracle /usr/local/java # <4>
sudo vi /etc/profile # <5>
----

<1> The new repository we added to the sources.list file is not trusted until we add the key with which every package on that repository is packaged. So by adding the key into our system we now trust this new repository.

<2> We ask Linux to go get the list of packages available on the new repository (as well as any other repositories on the sources.list file).

<3> We install Java 8 on our system.

<4> With the previous step Java is available on our system. The problem is that some of the tools we're using require an environment variable called JAVA_HOME. We could point directly to the directory where Java is at, and it would work, but when a new version of Java comes out, we would have to do this again and reload the environment by doing a logout and a login again. So to make that easier we'll add a soft link, and then when a new version of java is installed we just change the soft link and everything works without having to reload the environment.

<5> We need to modify the *_/etc/profile_* file to add the JAVA_HOME environment variable.

At the end of the file (*_G_*) we need to add (*_o_*) this lines:

[source,sh]
----
export JAVA_HOME=/usr/local/java
export PATH=$JAVA_HOME/bin:$PATH
----

With this, we have configured Java on our system.

=== Maven

Now we need to install Maven, our build tool. When we start building our tool you'll notice that we create java classes, HTML files, CSS files, some of these files need to be compiled, some need to be in a certain place in order to be found by the app. Maven helps us with all these chores.

The place to look for Maven is http://maven.apache.org, you can download it from there with your browser and skip the first instruction, or you can use *_wget_* (another Linux tool that enables us to download a file without a browser) and continue with the rest of the instructions to install it.

[source,sh]
----
wget http://apache.mirrors.tds.net/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz
tar -xvzf apache-maven-3.3.9-bin.tar.gz
sudo mkdir /opt/tools
sudo mv apache-maven-3.3.9 /opt/tools
sudo ln -s /opt/tools/apache-maven-3.3.9 /usr/local/maven
sudo vi /etc/profile
----

NOTE: Keep in mind that new releases come out all the time. Do the same steps for the newer versions of the tool.

We need to open the /etc/profile file again to add Maven to the environment.

We need to add a few lines to the end of the /etc/profile file we have open, and to do that we need to go to the end of the file and modify it to look like this:

[source,sh]
----
export JAVA_HOME=/usr/local/java # <1>
export MAVEN_HOME=/usr/local/maven # <2>
export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH # <3>
----

<1> Remains the same.

<2> New line adding the MAVEN_HOME environment variable.

<3> We insert the $MAVEN_HOME/bin directory to the PATH.

With those changes in place, we save and quit the file. To get the environment variables to load on our terminal the easiest way is to sign out and sign back again, open a terminal and check that everything is in place with the following instructions:

[source,sh]
----
java -version
mvn -v
----

Both of them should run and show you version numbers. Finally, our machine is ready for some coding!

== Let's Start Coding!

=== Spring Boot

Spring Boot is a tool part of the Spring Framework that enables developers to start quickly, they take care of setting up the application with opinionated defaults. This makes it easy to take advantage of what the Spring Framework has to offer. Without having to know too much you are able to build a solid application in minutes.

Let's do that! Go to http://start.spring.io and on the dependencies side type Web, hit enter to add it, and then type Devtools and hit enter again and then click on the Generate Project button, this will create a demo.zip file for you. Unzip it and move it to your projects folder

[source,sh]
----
cd Downloads
unzip demo.zip
mkdir ~/projects
mv demo ~/projects
cd ~/projects/demo
----

We now run our demo app with the following instruction:

[source,sh]
----
mvn spring-boot:run
----

We wait for it to show the following line:

----
... com.example.DemoApplication              : Started DemoApplication in 2.476 seconds (JVM running for 8.941)
----

We open a browser and go to http://localhost:8080 and we'll get a *_Whitelabel Error Page_* with a *_404_* near the bottom. What this means is that the app couldn't find a page to provide a response to the client request. We'll fix that by creating it:

[source,sh]
----
vi src/main/resources/static/index.html
----

This will open the editor on a new document, remember that when you open Vi you're in command mode to actually edit the file you would have to go into *_INSERT_* mode by pressing the *_i_* key (command).

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello World!</title>
  </head>
  <body>
    <h1>Hello World!</h1>
  </body>
</html>
----

Now visit http://localhost:8080 again and we should be getting the same *_Whitelabel Error Page_*. This means we need to redeploy the app. Go to the terminal where spring boot is running and use the combination of *_ctrl+shift+t_* keys to open a new tab. That tab should be in the project folder, just run to redeploy:

[source, sh]
----
mvn package -DskipTests=true
----

By the time this instruction ends, the redeploy should already be done, so just go visit http://localhost:8080 and you should get the hello world page.

=== Atom

Typing all that in in vi is really tiring, there has to be a better way right? Of course, there is, I'm just trying to show you the ropes with vi that's all, we should probably switch to *_vim_* and use plugins but I'll let you try that one on your own. We're going to try Atom.

[quote, atom.io]
Atom is a text editor that's modern, approachable, yet hackable to the core—a tool you can customize to do anything but also use productively without ever touching a config file.

Just go to http://atom.io in your browser download the .deb file and install it on your system with:

[source, sh]
----
sudo apt-get install git # <1>
sudo dpkg -i atom-amd64.deb # <2>
sudo apt-get install -f # <3>
----

<1> In order to manually install atom we need to install its dependencies. Git being the one we don't have installed yet. Git is a version control tool we'll be using down the road, so it doesn't hurt to install it here.

<2> Extract package to the proper directory.

<3> Install package.

We open atom from the terminal by:

[source, sh]
----
cd ~/projects/demo
atom .
----

On the left, we'll see a file manager with the text editor on the right. We'll navigate to src/main/resources/static and right-click to create a new file called *_hello.html_*. Then we type *_html_* and then press the *_tab_* key, whoa! What just happened, well Atom comes with a few plugins preinstalled one of them being Emmet. This plugin has HTML shortcuts to help speed up HTML development. You can see what Emmet is capable of at http://emmet.io/.

Save your changes and see your changes at http://localhost:8080/hello.html, if you get the 404 page again, you'll need to redeploy the app.

=== TODO App

image::start-spring-io.jpg[caption:"http://start.spring.io", alt="http://start.spring.io", link="http://start.spring.io"]

Let's start the app we'll be using throughout the workshop by going back to http://start.spring.io and renaming the artifact name to *_todo_* and adding *_Thymeleaf_* () and *_DevTools_* to the dependency list. Click on Generate Project to download zip file, extract it in our projects folder with:

[source, sh]
----
cd ~/projects/
unzip ~/Downloads/todo.zip
cd todo
atom .
----

Open the _pom.xml_ file and add the following between the description end tag and the parent beginning tag:

[source, xml]
----
<licenses>
    <license>
        <name>MIT License</name>
        <url>http://www.opensource.org/licenses/mit-license.php</url>
    </license>
</licenses>

<organization>
    <name>David Mendoza</name>
    <url>http://davidmendoza.org</url>
</organization>

<developers>
    <developer>
        <id>jdmr</id>
        <name>J. David Mendoza</name>
        <email>jdmendoza@swau.edu</email>
    </developer>
</developers>
----

Change everything to have your information on it.

=== Travis CI

[quote, wikipedia.org]
Travis CI is a hosted, distributed continuous integration service used to build and test software projects hosted on GitHub.

==== Why do we need a tool like Travis?

When you're building an application is always important to make sure that whatever you've built is working properly and you also want to make sure that you haven't broken anything else in the process. That's why you need a testing infrastructure. Maven already provides a way of testing your code if you have tests to run. And Spring Boot comes with JUnit support to build those tests, as a matter of fact, the project that came in the zip file already has a test in there and you can run it by going to the terminal and running the following instruction on the project's folder:

[source, sh]
----
mvn test
----

By building our application alongside tests that validate that our application is doing what it's supposed to do, our application will be a lot more solid when deployed. And when you code and have to introduce a big change to the codebase you can make it without wondering if something broke.

=== Git
[quote, git-scm.com]
Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.

This confidence that we're talking about grows even more if we use a _Version Control System_ to manage our codebase. How so? Well, when you add changes and start adding new dependencies and make that big change that in your mind would work, but when you're actually building it you realize that it doesn't work, now what? You have all these new dependencies on your codebase, you've changed a bunch of classes, HTML, etc. to try and make it work, and now it's all a mess if only there was a way of going to the way it was before I started adding this new feature. That's what a _Version Control System_ enables you to do. To go to any _version_ of the codebase with ease. The _Version Control Tool_ we're going to be using is *_Git_*. This _version control manager_ allows us to have a full blown _version control system_ in our computer, and if you want to use it to code from different computers and/or with different people, well, they all can have a copy of your repository and git has ways of synchronizing changes between the different repository copies.

Travis CI works in conjunction with Git to check out your changes once you've made a commit. Travis CI doesn't actually connect to your computer to get the changes, it uses a service that's called *_Github_*. This service can hold a copy of your local repository and share it with other people or tools (_like Travis CI_). We'll get to that in a bit, but first, let's configure Travis CI.

In the root directory of our application, we need to create a file called: _.travis.yml_ (notice the period in front of the file name)

image::travis-yml.jpg[]

The content of the file as you can see in the image is:

[source, yaml]
----
language: java
sudo: false

jdk:
  - oraclejdk8
----

First, we're telling Travis CI that the base code of our app is in Java, then that we won't need sudo privileges to execute our tests and finally what version of Java do we need to compile and run our tests.

We already installed Git to use Atom, but in case you didn't you would need to run this from the terminal shell:

[source, sh]
----
sudo apt-get install git
----

=== GitHub
[quote, github.com]
GitHub is home to all kinds of software projects, from simple programs to today’s most popular apps.

To use it we'll need to create an account, so go to http://github.com and sign up for one and verify your email. Once you've finished that create a new repository named todo.

image::github.jpg[]

After you've created the repository leave the instructions to create the local repository and open a new browser window to go to http://travis-ci.org and click on the _Sign in with GitHub_ button and then authorize Travis CI to interact with your GitHub Account, then click on your profile to enable your _todo_ repository for continuous integration.

Now we go back to our local repository creation instructions page and copy the first two lines and paste them in the terminal after we are certain that we are in the project's directory (_~/projects/todo_) and notice that I've changed the third line to use a period (.) instead of the README.md, this is because we have more files in the project and we want to add them:

[source, sh]
----
echo "# todo" >> README.md
git init
git add .
git commit -m "first commit"
git remote add origin https://github.com/david-mendoza/todo.git
git push -u origin master
----

Our build passed! Awesome! Now we need to let everyone know, right? To do that we go to http://travis-ci.org and click on the badge right next to our project and then choose Markdown from the options copy that code into the README.md file in Atom. To see more detailed instructions from Travis CI go to https://docs.travis-ci.com/user/status-images. Now go to your terminal shell again and do:

[source, sh]
----
git add .
git commit -m "Added Travis build status badge to the README"
git push
----

Now when somebody loads your GitHub repository page they'll see that our code is being tested and currently passing those tests.

=== Thymeleaf

[quote, thymeleaf.org]
Thymeleaf is a modern server-side Java template engine for both the web and standalone environments.

Our first iteration of our app is going to be a server-side rendered app. For this, we would need JSP's (_Java Server Pages_) which have been discontinued by the community behind JEE (_Java Enterprise Edition_). JEE is a specification that defines tools to build enterprise-grade applications with Java, we could follow that route in developing this application, but that road is a little more cumbersome. Spring was born of the need to simplify Java Enterprise development and has done such a great job that the current JEE spec pulled a lot of its standards from how Spring does things. Doing JEE development now is a lot easier than before but in my opinion, some things are still missing.

I don't want you to think that we're using Thymeleaf because JSP's got discontinued. Thymeleaf is a great tool and it provides a bunch of stuff that you can't get on JSP's alone, so I do believe that Thymeleaf is a _modern server-side_ rendering engine.

=== NetBeans

It's nice to have a text editor that will help with HTML and simple file edits but to do Java in a much more productive way we need an IDE, and there's where NetBeans comes in.

Download and install the JEE version of NetBeans from http://netbeans.org/downloads/. Open a terminal and go to the Downloads folder and do the following instructions there:

[source, sh]
----
chmod +x netbeans-8.1-javaee-linux.sh
./netbeans-8.1-javaee-linux.sh
----

The first instructions make the file executable and the second actually starts the installer. Follow the instructions to install and enable the Apache Tomcat installation (we don't need it for the workshop, but you might need it later). On the screen where it asks for the JDK please add the JDK_HOME link we already created and click next:

[source, sh]
----
/usr/local/java
----

Once installed we click on File > Open Project and then look for ~/projects/todo, and since NetBeans uses Maven's POM file to manage the project, it will just open.

image::netbeans.jpg[]

The first thing we need to do after we've opened a maven project is set it up by right-clicking on the project name and then click on the Properties option. Then a new window will show up.

image::netbeans-run-actions.jpg[]

Click on the Actions option on the left menu, and then on the right click on the Build project and in the Execute Goals input change the value to _package_, then the Clean and Build project option change it to _clean package_ and finally the Build with Dependencies change it to just _package_ again. Click on the Build project option again and click on the _Add_ button under _Set properties_ and choose the Skip Tests option. These changes are just to make the build process a little faster, it would work just fine without them too.

=== Code

The Spring starter tool adds the classes in what in my opinion is the wrong folder. To fix it we add a new package todo to our current package schema. To do that we need to right-click on the package name and select the New package option and type _todo_. Once you've finished creating both packages (source and test) drag the class in Source Packages to the new package and click on the Refactor button for both. Let's make sure we didn't break anything by testing the changes in the terminal type:

[source, sh]
----
mvn clean test
----

Next, we're going to build a test that checks if the title of the first page we get is TODO, it's not right now, but we'll make it so later.

On the Test Packages section we're going to create a new package called _home_ and in that package, we'll create the _HomeControllerTests_ Java Class by right clicking the new package and choosing the Java Class option. The class needs to look like this:

[source, java]
----
package org.davidmendoza.todo.home;

import static org.hamcrest.Matchers.containsString;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class HomeControllerTests {

    @Autowired
    private WebApplicationContext wac;

    private MockMvc mvc;

    @Before
    public void setup() {
        this.mvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    @Test
    public void shouldShowHomePage() throws Exception {
        mvc.perform(get("/"))
                .andExpect(status().isOk())
                .andExpect(content().string(containsString("<title>TODO</title>")))
                .andDo(print());
    }

}
----

NOTE: I'm removing most comments from classes for brevity, but it's recommended to keep them.

If we run the tests again we should get 1 failing test. Which is good, don't worry. Now let's fix that!

We create the package home on the Source Packages side and create a new java class in that package called _HomeController_ that should look like this:

[source, java]
-----
package org.davidmendoza.todo.home;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/")
public class HomeController {

    @GetMapping
    public String home() {
        return "home";
    }
}
-----

Now we need the page that's going to be rendered and returned to the browser. We do that with a Thymeleaf template called home.html in the src/main/resources/templates folder, you'll find the folder under Other Sources in NetBeans:

[source, html]
----
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org">
    <head>
        <title>TODO</title>
    </head>
    <body>
        <h1>TODO</h1>
    </body>
</html>
----

Is just a plain HTML page but with 2 namespaces on lines 2 and 3 as part of the HTML tag. These namespaces enable Thymeleaf to use special tags to perform special actions while building the page. We're just declaring them without using them for now. Let's run our tests again:

[source, sh]
----
mvn clean test
----

Awesome! Let's commit these changes to our _Version Control System_ before we break it.

[source, sh]
----
git add .
git commit -m "Created Hello Page"
git push
----

Actually, we haven't seen anything but code, how can we be confident that it actually worked! You're right, let's run it and open it on a browser on http://localhost:8080.

[source, sh]
----
mvn spring-boot:run
----

Great! It works! Although I really don't like typing _mvn spring-boot:run_ every time I want to run the application, it's too long for a repetitive process. Let's open the pom.xml file on NetBeans with _ctrl+shift+o_ you pull up a window that will search for all the files on the open projects, just type _pom.xml_ and choose it from the list. And look for the build tag at the bottom of the file and add the _defaultGoal_ tag to make it look like this:

[source, xml]
----
<build>
    <defaultGoal>spring-boot:run</defaultGoal> <!--1-->
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
----

<1> This is the only line you need to add.

And now you can stop the one that's running on the terminal (with _ctrl+c_), and run it again by just typing:

[source, sh]
----
mvn
----

=== TODO v1

There's a lot of ways of building an app. We'll use front/back because is the easiest to grasp when you're starting. What this means is that we'll build the client facing code first and leave the backend for last.

Let's start by adding a field where we'll input our todo.

[source, html]
----
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org">
    <head>
        <title>TODO</title>
    </head>
    <body>
        <h1>TODO</h1>
        <form action="#">
          <label for="name">TODO Name</label>
          <input type="text" name="name" id="name" />
          <input type="submit" />
        </form>
        <table>
          <thead>
            <tr>
              <th>TODOS</th>
              <th></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Walk the dog</td>
              <td><a href="#">Remove</a></td>
            </tr>
            <tr>
              <td>Take the trash out</td>
              <td><a href="#">Remove</a></td>
            </tr>
            <tr>
              <td>Buy groceries</td>
              <td><a href="#">Remove</a></td>
            </tr>
          </tbody>
        </table>
    </body>
</html>
----

And if we reload the app, it should look like this on the browser:

image::todo-html.jpg[]

With this we have a prototype, it doesn't work, but we can see how it looks. But it's missing aesthetics, it's just a little too plain. We'll fix that by adding another tool called *_Bootstrap_*.

=== Bootstrap

[quote, getbootstrap.com]
Bootstrap is the most popular HTML, CSS, and JS framework for developing responsive, mobile first projects on the web.

The use of *_Bootstrap_* will teach us basic HTML, CSS, and JavaScript. Without having to know a lot, our apps will look a lot better than what most of us can do without it. And besides building our app with this tool means it's mobile ready (we do need to know a few rules though).

Let's add it to our template and use it.

[source, html]
----
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org">
  <head>
    <title>TODO</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h1>TODO App</h1>
        </div>
        <div class="col-md-6">
          <form action="#">
            <div class="form-group">
              <label for="name">TODO Name</label>
              <input type="text" name="name" id="name" class="form-control"/>
            </div>
            <input type="submit" class="btn btn-primary btn-lg"/>
          </form>
        </div>
        <div class="col-md-6">
          <table class="table table-striped table-hover">
            <thead>
              <tr>
                <th>TODOS</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Walk the dog</td>
                <td><a href="#">Remove</a></td>
              </tr>
              <tr>
                <td>Take the trash out</td>
                <td><a href="#">Remove</a></td>
              </tr>
              <tr>
                <td>Buy groceries</td>
                <td><a href="#">Remove</a></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <script src="http://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  </body>
</html>
----
Ok, the first thing I want you to notice is the style line added to the HEAD section and the SCRIPT lines just before the closing BODY tag. The style line has Bootstrap's Cascading Style Sheet (CSS) rules, and with just that line would be enough to have the rules to style the page, but if we want some other goodies that the tool provides we need the SCRIPT lines at the bottom of the HTML page. Bootstrap requires JQuery (a JavaScript framework) to work, that's the reason why they're two script lines. Another thing you'll notice is the extra markup we added. This markup is what you'll need to learn if you're using this CSS framework. There're other frameworks out there that don't require as much markup, but Bootstrap is one of the most used out there. Now it should look something like this:

image::todo-bootstrap.jpg[]

If we want to see it on a display that's not as big as our desktop computer it will still look nice, thanks to the extra markup we added.

image::todo-bootstrap-mobile.jpg[]

Now, let's add a method to our HomeController to actually add the todo.

[source, java, linenums]
----
package org.davidmendoza.todo.home;

import java.util.ArrayList;
import java.util.List;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@RequestMapping("/")
public class HomeController {

    @GetMapping
    public String home() {
        return "home";
    }

    @PostMapping
    public String addTodo(@RequestParam String name, Model model) {
        List<String> todos = new ArrayList<>();
        todos.add(name);
        model.addAttribute("todos", todos);
        return "home";
    }
}
----

And the home.html file would need to be changed to:

[source, html, linenums]
----
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org">
  <head>
    <title>TODO</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h1>TODO App</h1>
        </div>
        <div class="col-md-6">
          <form action="#" th:action="@{/}" method="POST">
            <div class="form-group">
              <label for="name">TODO Name</label>
              <input type="text" name="name" id="name" class="form-control"/>
            </div>
            <input type="submit" class="btn btn-primary btn-lg"/>
          </form>
        </div>
        <div class="col-md-6">
          <table class="table table-striped table-hover">
            <thead>
              <tr>
                <th>TODOS</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              <tr th:each="todo : ${todos}">
                <td th:text="${todo}">Walk the dog</td>
                <td><a href="#">Remove</a></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <script src="http://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  </body>
</html>
----

The first thing you'll notice when reloading the app is that it's not showing your todo's anymore. That's because of the *_th:each_* in the TBODY > TR tag. This tag is a loop tag that will go through our list of todo's, but when we load the page the todos list is empty. We need to type a todo and click the submit button. Now it shows! Type another one, and is showing alright, but the last one is gone. That's because we are creating a new list each time we submit a todo. Let's fix that by adding our todo's to the _Session_ (is a special storage place our server assigns to each client).

[source, java, linenums]
----
package org.davidmendoza.todo.home;

import java.util.ArrayList;
import java.util.List;
import javax.servlet.http.HttpSession;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@RequestMapping("/")
public class HomeController {

    @GetMapping
    public String home(HttpSession session, Model model) {
        List<String> todos = (List<String>) session.getAttribute("todos");
        if (todos == null) {
            todos = new ArrayList<>();
            session.setAttribute("todos", todos);
        }
        model.addAttribute("todos", todos);
        return "home";
    }

    @PostMapping
    public String addTodo(@RequestParam String name, Model model, HttpSession session) {
        List<String> todos = (List<String>) session.getAttribute("todos");
        todos.add(name);
        model.addAttribute("todos", todos);
        return "home";
    }
}
----
